import re
import sha3
import sys



types = set([
    "byte",
    "byte[]",
    "bytes",
    "boolean",
    "boolean[]",
    "string",
    "uint8",
    "uint64",
    "uint160",
    "uint256",
    "int8",
    "int64",
    "int160",
    "int256",
    "address",
    "void",
    "address[]",
    "int8[]",
    "int160[]",
    "uint160[]",
    "int256[]",
    "uint256[]",
    "address[]",
    "string[]",
    "bool",
    "bool[]",
    "uint8[]",
    "int64[]",
    "uint64[]"
])
arrays = set([
    "array",
    "fixed_array"
])

for i in range(1, 32):
    types.add('bytes' + str(i))

def go_extract(pattern, text, delim, flag, replace, line_start):
    matched_text = [line for line in text if pattern in line]

    for line in matched_text:
        new_line = line.replace(' ', '')
        # if line_start:
        #     print(pattern)
        #     print(new_line)
        if new_line[:len(pattern)] != pattern and line_start:
            continue
        type = new_line
        if replace:
            type = type.replace(pattern, '')
        type = type[:type.find(delim) + flag]
        types.add(type)

def extract_special_types(pattern, text, delim, flag, replace):
    go_extract(',' + pattern, text, delim, flag, replace, False)
    go_extract(' ' + pattern, text, delim, flag, replace, False)
    go_extract(pattern, text, delim, flag, replace, True)

def parse_array_types(pattern, param):
    # print(param)
    # print(param[:len(pattern)])
    # print(pattern)
    if param[:len(pattern)] != pattern:
        return False
    param = param[:-1]
    param = param.replace(pattern, '')
    # print(param)
    if param not in types:
        return False
    return True


lines = open(sys.argv[1]).read().splitlines()

extract_special_types("WASMSDK_ABI_STRUCT(", lines, ',', False, True)
extract_special_types("storage<", lines, '>', True, False)
extract_special_types("array<", lines, '>', True, False)
extract_special_types("property<", lines, '>', True, False)
extract_special_types("fixed_array<", lines, '>', True, False)
extract_special_types("storage_array<", lines, '>', True, False)
extract_special_types("mapping<", lines, '>', True, False)

# print(types)

matched_lines = [line for line in lines if "WASMSDK_ABI(" in line]
j = 0
corr_lines = []
for i in range(0, len(lines)):
    if matched_lines[j] == lines[i]:
        corr_lines.append(lines[i + 1])
        j += 1
    if j >= len(matched_lines):
        break

methods = []
j = 0
abi_names = []
functions = []
keccaks = []
abi = open(sys.argv[1][:len(sys.argv[1]) - 4] + '.abi', 'w')
for line in matched_lines:
    method_type = 'void'
    method = line.replace('WASMSDK_ABI(', '').replace(' ', '')[:-1]
    if method[len(method) - 2] != ')':
        last_occur = method[:-1].rfind('"')
        method_type = method[last_occur + 1:-1]
        method = method[:last_occur - 1]
    keccak = sha3.keccak_256()
    keccak.update(method[1:-1].encode())
    new_keccak = keccak.hexdigest()[:8]
    final_hash = '0x' + new_keccak[6:8] + new_keccak[4:6] + new_keccak[2:4] + new_keccak[0:2]
    keccaks.append(final_hash)
    method = method[1:-2]
    colon_occ = method.find('(')
    method_name = method[:colon_occ]
    params = method[colon_occ + 1:].split(',')
    output_params = ''
    if method_type not in types and not parse_array_types('array<', method_type) and \
            not parse_array_types('fixed_array<', method_type):
        raise Exception('Unsupported method type (' + method_type + ')')
    for param in params:
        if param not in types and param != '' and not parse_array_types('array<', param) and \
                not parse_array_types('fixed_array<', parami):
            raise Exception('Unsupported parameter type (' + param + ')')
        output_params += param + ' '

    abi.write('METHOD_TYPE: ' + method_type + '\n')
    abi.write('METHOD_NAME: ' + method_name + '\n')
    abi.write('PARAMS: ' + output_params + '\n\n')

    methods.append(method_name)
    corr_line = corr_lines[j]
    corr_line = re.split('[( {,)]', corr_line)

    abi_name = corr_line[2]
    functions.append(abi_name)
    abi_names.append(('abi_' + abi_name).upper())
    j += 1

    new_corr_line = []
    for elem in corr_line:
        if elem != '':
            new_corr_line.append(elem)

    for k in range(3, len(new_corr_line)):
        index = int((k - 3) / 2)
        if k % 2 == 1 and new_corr_line[k] != params[index]:
            raise Exception(
                'Method parameter mismatched (' + method_name + ', ' + new_corr_line[k] + ' != ' + params[index] + ')')

lines = open(sys.argv[1]).read().splitlines()
matched_lines = [line for line in lines if "WASMSDK_ENTRY_POINT {" in line]

if len(matched_lines) != 0:
    raise Exception('Don\'t define WASMSDK_ENTRY_POINT method, because its autogenerated')

cpp = open(sys.argv[2], 'w')
cpp.write('\n'.join(lines))
cpp.write("\n\nWASMSDK_ENTRY_POINT {\n")
cpp.write("    uint32 method_signature = read_method_signature();\n")
cpp.write("    if (method_signature == static_cast<uint32>(-1)) {\n")
cpp.write("        fallback();\n")
cpp.write("        return;\n")
cpp.write("    }\n")
cpp.write("    switch (method_signature) {\n")
for i in range(0, len(abi_names)):
    if methods[i] == "constructor":
        cpp.write("    case " + "0x00000000" + ":\n")
    else:
        cpp.write("    case " + keccaks[i] + ":\n")
    cpp.write("        invoke_contract_method(" + functions[i] + ");\n")
    cpp.write("        break;\n")
cpp.write("    default:\n")
cpp.write("        system_halt(HALT_CODE_UNKNOWN_METHOD);\n")
cpp.write("    }\n")
cpp.write("    return;\n")
cpp.write("}\n")
cpp.close()
